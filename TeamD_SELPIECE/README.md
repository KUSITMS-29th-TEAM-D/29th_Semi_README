### *학회원 여러분께 제공하는 29기 세미밋업데이 산출물 readme 의 레퍼런스 문서입니다. 하단 내용은 모두 예시로 구성된 것으로, 자유롭게 readme 파일을 구성해주시면 됩니다.*
<br>

28기 세미밋업 README 파일 링크

[GitHub - kusitms-com/28th_Semi_README: 28기 세미밋업용 산출물 리드미 저장 Repository입니다.](https://github.com/kusitms-com/28th_Semi_README)

# 🌟 서비스명

<img width="848" alt="KakaoTalk_Photo_2023-10-04-02-49-47" src="https://github.com/kusitms-com/28th_Semi_README/assets/115339354/bba51986-1d36-4f5d-aac9-d82d81508e0b">

<br><br>

## 서비스 소개를 적어주세요.

> OOO은 … 서비스입니다.
<br>

## 🕊️ 팀명
### 팀명 :
<br>

## R&R

| 분야 | 이름 | 포지션 |
| --- | --- | --- |
| 기획 | 김OO | 📈서비스 기획 - 서비스 정책 확립, 비즈니스 모델 구축 |
| 기획 | 김OO | 📊서비스 기획 - 유저 리서치, 와이어프레임 작성, UX writing |
| 기획 | 박OO | 📋 서비스 기획 - 서비스 정책 확립, 비즈니스 모델 구축 |
| 기획 | 양OO | 🔐 기획 리드, 서비스 기획 - 와이어프레임 작성, 랜딩 페이지 테스트 |
| 디자인 | 한OO | 📢 프로젝트 매니징, 서비스 디자인 |
| 개발 | 이OO | 🔦 프론트엔드 리드, iOS 화면 UI 구현, 서버 연동 |
| 개발 | 정OO | 📱 iOS 화면 UI 구현, 서버 연동 |
| 개발 | 김OO | 💻 백엔드 리드, DB 및 API 구축, 서버 배포 |
| 개발 | 한OO | 🖥️ DB 및 API 구축, 서버 배포 |
<br>

## 🔎 목적 및 필요성

### 목적

이 서비스를 통해 어떤 문제를 해결하고 싶은지, 서비스를 기획하는 목적을 작성해주세요. 
<br>
### 필요성

데스크리서치, 유저리서치 등을 바탕으로 파악한 이 서비스의 필요성을 작성해주시면 됩니다. 
<br><br><br>
## 📊 리서치 및 시장조사
### 1️⃣ 경쟁사 분석
<br>

### 2️⃣ 목표 시장

| TAM | SAM | SOM |
| --- | --- | --- |
|  |  |  |
| 000만 명 | 000만 명 | 00만 명 |

> *앱 다운로드 건 수 00만 건(수익시장의 00%) 확보를 시작으로, 점차 시장을 넓혀갈 예정입니다.*
>
<br>

### 3️⃣ 유저리서치 분석
<br>

## 👀 서비스 타겟층 정의


00의 목표 타겟은 … 입니다.

| 분류 | 1차 타겟 유저 | 2차 타겟 유저 |
| --- | --- | --- |
| 타겟 설정 |  |  |
| 관련 기능 |  |  |
<br>

## 💡 서비스 소개

### **개요**
<br>

### 핵심 기능

***팀 내의 논의 결과에 따라 메뉴구조도, 플로우차트, 서비스블루프린트 등의 기획문서를 작성하여 첨부해주세요.***
<br><br><br>
## 📊 서비스 비즈니스 모델


|  | 관련 파트너 1 | 관련 파트너 2 | 내용 |
| --- | --- | --- | --- |
| STEP 1 |  |  |  |
| STEP 2 |  |  |  |

<br><br>

## **🎨 디자인 무드보드**

<img width="848" alt="KakaoTalk_Photo_2023-10-04-02-51-36" src="https://github.com/kusitms-com/28th_Semi_README/assets/115339354/982e06ae-9957-487c-b5d3-10c7f369fcbb">

<br><br>

## **🔍 System Architecture**

<img width="1329" alt="쿨피스_아키텍처" src="https://github.com/KUSITMS-29th-TEAM-D/29th_Semi_README/assets/113084292/72669e0b-e379-4690-b4c9-cd4737987150">

<br><br>

## **📜 ERD 설계도**

<img width="1478" alt="쿨피스_ERD_2" src="https://github.com/KUSITMS-29th-TEAM-D/29th_Semi_README/assets/113084292/ff8d9ed7-1a47-4fab-a167-618e0bb6efdd">

<br><br>

## **🛠️ Stacks**

### **📘 Web/Android**

  <img src="https://img.shields.io/badge/React-61DAFB?style=flat-square&logo=react&logoColor=black"> <img src="https://img.shields.io/badge/Typescript-3178C6?style=flat-square&logo=typescript&logoColor=white"> <img src="https://img.shields.io/badge/Styled Components-DB7093?style=flat-square&logo=styled-components&logoColor=white"/> <img src="https://img.shields.io/badge/Vite-646CFF?style=flat-square&logo=vite&logoColor=white"> <img src="https://img.shields.io/badge/Recoil-3578E5?style=flat-square&logo=recoil&logoColor=white"> <img src="https://img.shields.io/badge/Axios-5A29E4?style=flat-square&logo=axios&logoColor=white"> <img src="https://img.shields.io/badge/Vercel-000000?style=flat-square&logo=vercel&logoColor=white">

**`React`** 
- React는 가장 핵심 요소인 Virtual Dom을 이용하여 불필요한 화면 갱신을 최소화합니다. 이를 통해, 성능 향상을 시킬 수 있으며 빠른 렌더링을 지원합니다.
- React의 생태계는 비교적 방대하며, 개발자 커뮤니티도 활발합니다. 그만큼 다양한 라이브러리, 플러그인 등이 개발되어 있어 생산성을 향상시킬 수 있습니다.
- React는 컴포넌트 기반 아키텍처를 채택하고 있으며, UI 요소들을 컴포넌트로 분리하여 개발하고 조합하는 방식으로 구성할 수 있습니다. 따라서, 컴포넌트의 재사용성을 용이하게 하며, 코드 수정 및 유지보수에 효율적입니다.

**`Typescript`** 
- Typescript는 Javascript 기반의 정적 타입 문법을 추가한 언어로, 타입 추가로 인해 안정적인 개발과 높은 수준의 코드 품질을 유지할 수 있습니다.
- 컴파일 과정에서 타입을 지정하기 때문에 컴파일 에러 예방, 손쉬운 디버깅이 가능해집니다.
- 변수, 함수, 매개변수, 함수 반환 값 등 타입 어노테이션(type annotation)을 추가할 수 있으며, 이를 통해 개발자가 코드의 의도를 명확하게 표현할 수 있습니다. 따라서 다른 개발자들이 코드를 이해하기 쉽게 도와줄 수 있습니다.

**`Styled Components`**  
- Styled Components는 CSS를 Javascript로 작성된 컴포넌트에 바로 삽입하는 기법으로, 컴포넌트 스타일링을 쉽게 구현할 수 있습니다. 뿐만 아니라, Javascript의 기능을 활용하여 동적인 스타일을 생성하거나 조건부 스타일을 적용할 수 있습니다.
- CSS를 컴포넌트 기반으로 스타일링함으로써 컴포넌트 단위로 스타일을 정의하고 관리할 수 있습니다. 따라서, 컴포넌트 지향적인 스타일링이 가능하하며, 전역 스타일 충돌을 방지할 수 있습니다.

**`Vite`**  
- Vite는 개발 서버가 빠르게 번들링하고 HMR(Hot Module Replacement, 앱을 종료하지 않고 갱신된 파일만 교체하는 방식)을 지원함으로써 빠른 개발 속도를 제공합니다.
- Vite의 사전 번들링 기능은 ESbuild를 사용하고 있어 기존 번들러 대비 10~100배 빠른 번들링 속도를 가지고 있습니다.

**`Recoil`**  
- Recoil은 React를 위한 상태 관리 라이브러리이기 때문에, React의 기본적인 훅(hook)과 개념을 활용하여 상태 관리를 보다 쉽고 직관적으로 할 수 있습니다. 따라서, 러닝 커브가 비교적 낮아 쉽게 사용할 수 있습니다.
- Recoil은 비동기 처리를 기반으로 작성되어 동시성 모드를 제공합니다. 따라서, 다른 전역 상태 라이브러리처럼 비동기 처리 라이브러리에 의존할 필요가 없습니다.

**`Axios`**  
- 크로스 브라우징 최적화로 브라우저 호환성이 뛰어나며, Javascript 내장 라이브러리인 fetch와 다르게 오래된 브라우저 지원 불가에 대한 걱정이 필요하지 않습니다.
- Promise 기반으로 만들어졌기 때문에 데이터를 다루기 편리합니다. 뿐만 아니라, 많은 기능을 제공하고 있어 요청과 응답을 보다 쉽게 다룰 수 있는 편의성을 제공합니다.

**`Vercel`**
- Vercel은 서버리스 아키텍쳐 기반으로, 사이트가 원활하게 작동하도록 모든 관리 작업을 처리합니다. 뿐만 아니라, CI/CD를 쉽게 설정할 수 있습니다. 따라서 개발자가 코드 개발 외적으로 관리해야 할 요소를 줄여줍니다.
- CDN을 통해 전 세계 여러 위치에 제공하여 빠른 로딩 속도와 확장성을 제공합니다.

<br />

### **📗 Server**

<img src="https://img.shields.io/badge/JDK 17-007396?style=flat-square&logo=openjdk&logoColor=white"> <img src="https://img.shields.io/badge/Spring boot 3.2.4-6DB33F?style=flat-square&logo=springboot&logoColor=white"> <img src="https://img.shields.io/badge/Gradle-02303A?style=flat-square&logo=gradle&logoColor=white"> <img src="https://img.shields.io/badge/Spring security-6DB33F?style=flat-square&logo=springsecurity&logoColor=white"> <img src="https://img.shields.io/badge/JWT-FC494A?style=flat-square&logo=jsonwebtokens&logoColor=white"> <img src="https://img.shields.io/badge/Redis-DC382D?style=flat-square&logo=redis&logoColor=white"> <img src="https://img.shields.io/badge/Hibernate-59666C?style=flat-square&logo=hibernate&logoColor=white"> <img src="https://img.shields.io/badge/MySQL-4479A1?style=flat-square&logo=mysql&logoColor=white"> <img src="https://img.shields.io/badge/Nginx-009639?style=flat-square&logo=Nginx&logoColor=white"> <img src="https://img.shields.io/badge/Docker-2496ED?style=flat-square&logo=Docker&logoColor=white"> <img src="https://img.shields.io/badge/Github Actions-2088FF?style=flat-square&logo=Github Actions&logoColor=white">

**`Spring Boot`**
  - 설정이 간소화되고 개발 생산성이 향상되는 스프링 기반의 프레임워크로, 내장된 톰캣과 같은 서버를 사용하여 애플리케이션을 간단히 배포할 수 있습니다.

**`Gradle`**
  - 의존성 관리 및 빌드 도구로, Groovy나 Kotlin 기반의 DSL을 사용하여 프로젝트를 빌드하고 관리할 수 있으며, 멀티 프로젝트 빌드 및 다양한 플러그인 지원으로 유연성이 뛰어납니다.

**`Spring Security`**
  - 다양한 인증 및 권한 부여 기능을 제공하여 보안을 강화하며, 사용자 관리, 인증 프로세스 설정, 접근 제어 등의 보안 요구 사항을 손쉽게 구현할 수 있습니다.
  - OAuth2.0 프로토콜을 통해 인증 서버에 접근하는 방식으로 소셜 로그인을 구현할 수 있습니다.

**`JPA(Hibernate)`**
- 객체와 관계형 데이터베이스 간의 매핑을 단순화하여 데이터베이스에 대한 복잡한 SQL 쿼리를 작성하지 않고도 데이터를 다룰 수 있습니다. 
- 객체지향 프로그래밍의 장점을 그대로 유지하면서 데이터베이스와의 상호작용을 편리하게 할 수 있습니다.

**`MySQL`**
- 오픈 소스 관계형 데이터베이스 관리 시스템(RDBMS)으로, 안정적이고 높은 성능을 제공합니다. 
- 대용량 데이터 처리와 트랜잭션 처리에 효과적이며, 다양한 운영 환경에서 널리 사용됩니다.

**`Redis`**
- 메모리 기반의 데이터 저장소로, 빠른 속도와 낮은 지연 시간을 제공하여 데이터의 실시간 처리와 캐싱에 적합합니다.
- 생산성이 뛰어나고 확장성이 우수하여 대규모 시스템에서도 효율적으로 사용될 수 있습니다.
- 소셜 로그인 과정에서 Refresh Token을 저장하는 용도로 활용할 수 있습니다.

**`JWT`**
- JSON 웹 토큰으로, 토큰 기반의 인증 방식을 사용하여 사용자 인증 및 권한 부여를 수행합니다.
- 토큰 자체에 정보를 포함하므로 데이터베이스 조회 없이도 효율적인 인증이 가능하며, 암호화된 형태로 토큰을 전달하여 보안을 강화할 수 있습니다.

**`Nginx`**
- 로드 밸런싱과 리버스 프록시 기능을 통해 트래픽을 새로운 버전의 애플리케이션으로 원활하게 정환할 수 있습니다.

**`Docker`**
- CI/CD를 진행 할 때 실행 가능한 서버 애플리케이션을 도커를 통해 컨테이너화 시켜 서버 환경에서 쉽게 실행할 수 있게 합니다.

**`Docker Compose`**
- 복잡한 애플리케이션을 쉽게 정의하고 관리할 수 있으며, 개발 환경에서부터 프로덕션 배포까지 일관된 환경을 유지할 수 있습니다.

**`Github Actions`**
- 자동화된 워크플로우를 통해 Blue/Green 환경에 대한 코드 변경을 각각 자동으로 배포할 수 있습니다.
- Github에서 제공하는 CICD 프로세스로 젠킨스와 같은 별도의 파이프라인을 구축할 필요 없다는 장점이 있습니다.

**`NCP(Naver Cloud Platform)`**
- NCP Server
  - 확장성과 유연성을 바탕으로 다양한 인스턴스를 효율적으로 관리 및 배포할 수 있습니다.
  - 체계적인 가이드라인을 제공해 빠르고 정확하게 서버 구축이 가능합니다.
- Object Storage
  - 데이터 무결성 및 복원력을 보장하고 초대용량 데이터를 저장할 수 있습니다. 
  

  

<br>

### **🗣️ Co-working-Tool**

<img src="https://img.shields.io/badge/GitHub-181717?style=flat-square&logo=github&logoColor=white"/> <img src="https://img.shields.io/badge/Slack-4A154B?style=flat-square&logo=slack&logoColor=white"/> <img src="https://img.shields.io/badge/Notion-000000?style=flat-square&logo=notion&logoColor=white"/> <img src="https://img.shields.io/badge/Figma-F24E1E?style=flat-square&logo=figma&logoColor=white"/> <img src="https://img.shields.io/badge/Postman-FF6C37?style=flat-square&logo=postman&logoColor=white"/>

<br><br>

## 🔖 Naming Rules

### **📘 Web/Android**

- **컴포넌트명 (components)**
    - **폴더명** : 컴포넌트랑 직접적인 폴더명은 PascalCase 사용
    - **파일명** : PascalCase 사용
- **함수명, 변수명, 이미지 파일명** : camelCase 사용
- **상수명** : SNAKE_CASE 사용
- **타입명** : PascalCase 사용

### **📗 Server**

- **패키지명** : 한 단어 소문자 사용 `Ex) service`
- **클래스명** : 파스칼 케이스 사용 `Ex) JwtUtil`
- **메서드명** : 카멜 케이스 사용, 동사로 시작  `Ex) getUserScraps`
- **변수명** : 카멜 케이스 사용 `Ex) jwtToken`
- **상수명** : 대문자 사용 `Ex) EXPIRATION_TIME`
- **컬럼명** : 스네이크 케이스 사용 `Ex) users_id`

<br>

## **️🔏 Commit Convention**

### **📘 Web/Android**

- 형식: `태그: 커밋 내용 (#이슈번호)`

### **📗 Server**
- 이슈 번호 붙여서 커밋 `Ex) #4 [feat] : 로그인 기능 구현`
- Body는 추가 설명 필요하면 사용

### **📌 Type**

| commit 명    | commit 뜻 |
|-------------| --- |
| `feat`      | 새로운 기능 추가 / 일부 코드 추가 / 일부 코드 수정 (리팩토링과 구분) / 디자인 요소 수정 |
| `fix`       | 버그 수정 |
| `refactor`  | 코드 리팩토링 |
| `style`      | 코드 의미에 영향을 주지 않는 변경사항 (코드 포맷팅, 오타 수정, 변수명 변경, 에셋 추가) |
| `chore`      | 빌드 부분 혹은 패키지 매니저 수정 사항 / 파일 이름 변경 및 위치 변경 / 파일 삭제 |
| `docs`       | 문서 추가 및 수정 |
| `rename`      | 패키지 혹은 폴더명, 클래스명 수정 (단독으로 시행하였을 시) |
| `remove`      | 패키지 혹은 폴더, 클래스를 삭제하였을 때 (단독으로 시행하였을 시) |

<br>

## **🔀 Git Flow**

- 생성한 이슈에 따라서 브랜치 생성 `Ex) feature/#4/login`

| 브랜치 명 | 설명                                                     |
|------|--------------------------------------------------------|
| `main` | 소프트웨어 제품 배포하는 용도로 쓰는 브랜치                               |
| `develop` | 개발용 default 브랜치로, 이 브랜치를 기준으로 feature 브랜치를 따고, 합치는 브랜치 |
| `feat` | 단위 기능 개발용 브랜치                                          |
| `fix`  | 단위 기능 개발 수정용 브랜치                                       |
| `hotfix` | main branch에 배포 코드가 합쳐진 후, 버그 발생 시 긴급 수정하는 브랜치         |

